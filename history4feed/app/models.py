from textwrap import dedent
from typing import Iterable
from urllib.parse import urlparse
import uuid
from django.conf import settings
from django.db import models
from rest_framework import validators
from uuid import uuid4
from django.utils.text import slugify
import hyperlink
from django.db.models import Min, Max


POST_DESCRIPTION_MAX_LENGTH = 2 * 1024 * 1024 # 2MiB
FEED_DESCRIPTION_MAX_LENGTH = 10*1024 # 10KiB

class JobState(models.TextChoices):
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED  = "failed"

class FeedType(models.TextChoices):
    RSS = "rss"
    ATOM = "atom"
    SKELETON = "skeleton"

# Create your models here.

class SlugField(models.CharField):
    def get_prep_value(self, value):
        return slugify(str(value))

class Category(models.Model):
    name = SlugField(max_length=1000, primary_key=True)


def stix_id(url):
    return uuid.uuid5(uuid.UUID(settings.HISTORY4FEED_NAMESPACE), url)

def normalize_url(url):
    try:
        u = hyperlink.parse(url)
        return u.normalize(url).to_text()
    except Exception as e:
        raise validators.ValidationError(f"normalize_url failed for `{url}`: {e}")
    
AUTO_TITLE_TRAIL = "%^%*(%"

class Feed(models.Model):
    id = models.UUIDField(primary_key=True, help_text="UUID of feed generated by history4feed")
    title = models.CharField(max_length=1000, help_text="found in the <channel> of RSS output. Is always kept up to date with the latest feed import values for this property.")
    description = models.CharField(max_length=FEED_DESCRIPTION_MAX_LENGTH, help_text="found in the <channel> of RSS output. Is always kept up to date with the latest feed import values for this property.")
    url = models.URLField(max_length=1000, unique=True, help_text=dedent("""
        The URL of the RSS or ATOM feed

        Note this will be validated to ensure the feed is in the correct format.
    """), validators=[normalize_url])
    earliest_item_pubdate = models.DateTimeField(null=True, help_text="pubdate of earliest post")
    latest_item_pubdate = models.DateTimeField(null=True, help_text="pubdate of latest post")
    datetime_added = models.DateTimeField(auto_now_add=True, editable=False, help_text="date feed entry was added to database")
    feed_type = models.CharField(choices=FeedType.choices, max_length=12, null=False, editable=False, help_text="type of feed")
    pretty_url = models.URLField(max_length=1000, null=True, default=None)

    def get_post_count(self):
        return self.posts.count()
    
    def save(self, *args, **kwargs) -> None:
        if not self.id:
            self.id = stix_id(self.url)
        self.earliest_item_pubdate, self.latest_item_pubdate = self.posts.aggregate(min=Min('pubdate'), max=Max('pubdate')).values()
        return super().save(*args, **kwargs)
    
    def get_pretty_url(self):
        return self.pretty_url or self.url
    
    def set_title(self, title):
        if not self.title or self.title.endswith(AUTO_TITLE_TRAIL):
            self.title = title + AUTO_TITLE_TRAIL
    
    def set_description(self, description):
        if not self.description or self.description.endswith(AUTO_TITLE_TRAIL):
            self.description = description + AUTO_TITLE_TRAIL

class Job(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4, help_text="UUID of job")
    state = models.CharField(choices=JobState.choices, max_length=12, default=JobState.PENDING, null=False, help_text="state of the job")
    run_datetime = models.DateTimeField(auto_now_add=True, editable=False, help_text="time job was executed")
    earliest_item_requested = models.DateTimeField(null=True, help_text="shows the earliest time for posts requested. Useful for when jobs are run to see if the time range it runs across is expected")
    latest_item_requested = models.DateTimeField(null=True, help_text="shows the latest time for posts requested")
    feed = models.ForeignKey(Feed, on_delete=models.CASCADE)
    info = models.CharField(max_length=FEED_DESCRIPTION_MAX_LENGTH, help_text="contains a useful summary of the job (e.g. number of posts retrieved, errors logged)")
    include_remote_blogs = models.BooleanField(default=False)

    def urls(self):
        retval = {}
        ft_job: FulltextJob = None
        for ft_job in self.fulltext_jobs.all():
            retval[ft_job.status] = retval.get(ft_job.status, [])
            retval[ft_job.status].append(dict(url=ft_job.link, id=ft_job.post_id))
        return retval
    
    def should_skip_post(self, post_link: str):
        return (not self.include_remote_blogs) and urlparse(self.feed.url).hostname.split('.')[-2:] != urlparse(post_link).hostname.split('.')[-2:]


class FullTextState(models.TextChoices):
    RETRIEVED  = "retrieved"
    SKIPPED    = "skipped"
    FAILED     = "failed"
    RETRIEVING = "retrieving"

class Post(models.Model):
    id = models.UUIDField(primary_key=True, help_text="UUID of items generated by history4feed")
    datetime_added = models.DateTimeField(auto_now_add=True, editable=False)
    datetime_updated = models.DateTimeField(auto_now=True)
    title = models.CharField(max_length=1000, help_text="found in the <item> element of feed output")
    description = models.CharField(max_length=POST_DESCRIPTION_MAX_LENGTH, blank=True, help_text="found in the <item> element of feed output")
    link = models.URLField(max_length=1000, help_text="link to full article. found in the <item> element of feed output", validators=[normalize_url])
    pubdate = models.DateTimeField(help_text="date of publication.")
    author = models.CharField(max_length=1000, help_text="author of the post", null=True, blank=True)
    categories = models.ManyToManyField(Category, related_name="posts", help_text="categories of the post", blank=True)
    feed = models.ForeignKey(Feed, on_delete=models.CASCADE, related_name="posts", help_text="feed id this item belongs too")
    is_full_text = models.BooleanField(default=False, help_text="if full text has been retrieved")
    content_type = models.CharField(default="plain/text", max_length=200, help_text="content type of the description")
    added_manually = models.BooleanField(default=False)

    class  Meta:
        constraints = [
            models.UniqueConstraint(fields=["link", "feed"], name="unique_link_by_feed"),
        ]

    def add_categories(self, categories):
        categories = [Category.objects.get_or_create(name=name)[0] for name in categories]
        self.categories.set(categories)


    def save(self, *args, **kwargs) -> None:
        if not self.id:
            pubdate = self.pubdate.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
            self.id = stix_id(f"{self.feed.id}+{self.link}+{pubdate}")
        return super().save(*args, **kwargs)

class FulltextJob(models.Model):
    post = models.ForeignKey(Post, on_delete=models.SET_NULL, null=True, related_name="fulltext_jobs")
    job = models.ForeignKey(Job, related_name="fulltext_jobs", on_delete=models.CASCADE)
    status = models.CharField(max_length=15, choices=FullTextState.choices, default=FullTextState.RETRIEVING)
    error_str = models.CharField(max_length=1500, null=True, blank=True)
    link = models.CharField(max_length=1500)